var documenterSearchIndex = {"docs":
[{"location":"#Barriers.jl","page":"Barriers.jl","title":"Barriers.jl","text":"","category":"section"},{"location":"","page":"Barriers.jl","title":"Barriers.jl","text":"Barriers","category":"page"},{"location":"#Barriers","page":"Barriers.jl","title":"Barriers","text":"Barriers\n\n(Image: Dev)\n\nBarriers.jl provides various implementations of barrier for shared memory synchronization and reductions in concurrent Julia programs.  It respects the cooperative multitasking nature of Julia's task system while allowing the programmers to express and leverage the structure of the parallelism in their program.\n\nSee the documentation for more information.\n\nNote: Appropriate insertion of barriers for correct and efficient parallel program is rather hard.  For casual programming, it is recommended to ues higher-level data-parallel approaches.\n\nA toy example\n\njulia> using Barriers\n\njulia> xs = zeros(Bool, 20);\n\njulia> xs[end÷2] = true;\n\njulia> barrier = Barrier(length(xs) - 2);\n\njulia> @sync for i in 2:length(xs)-1\n           b = barrier[i-1]\n           Threads.@spawn begin\n               if i == 2\n                   println()\n                   join(stdout, (\" █\"[x + 1] for x in xs))\n                   println()\n               end\n               for _ in 1:8\n                   cycle!(b)               # wait for print\n                   l, c, r = xs[i-1:i+1]   # (loading)\n                   cycle!(b)               # wait for load\n                   xs[i] = l ⊻ (c | r)     # (storing)\n                   cycle!(b)               # wait for store\n                   if i == 2\n                       join(stdout, (\" █\"[x + 1] for x in xs))\n                       println()\n                   end\n               end\n           end\n       end\n\n         █\n        ███\n       ██  █\n      ██ ████\n     ██  █   █\n    ██ ████ ███\n   ██  █    █  █\n  ██ ████  ██████\n ██  █   ███     █\n\nSee the benchmarks for examples with actual performance considerations.\n\n\n\n\n\n","category":"module"},{"location":"#Barrier-factories","page":"Barriers.jl","title":"Barrier factories","text":"","category":"section"},{"location":"","page":"Barriers.jl","title":"Barriers.jl","text":"Barrier factories create a barrier with a given property without specifying the actual implementation. They use simple heuristics to determine an appropriate implementation.","category":"page"},{"location":"","page":"Barriers.jl","title":"Barriers.jl","text":"Barrier\nreduce_barrier\nfuzzy_barrier\nfuzzy_reduce_barrier","category":"page"},{"location":"#Barriers.Barrier","page":"Barriers.jl","title":"Barriers.Barrier","text":"Barrier(ntasks::Integer) -> barrier\n\nCreate a barrier for ntasks tasks.  Call cycle!(barrier[i]) in the i-th task for waiting for other tasks to arrive at the same phase.\n\nThe actual returned concrete type is not the part of API. It is CentralizedBarrier for small ntasks and DisseminationBarrier for large ntasks.\n\nSupported method: cycle!\n\n\n\n\n\n","category":"type"},{"location":"#Barriers.reduce_barrier","page":"Barriers.jl","title":"Barriers.reduce_barrier","text":"reduce_barrier(op, T::Type, ntasks::Integer) -> barrier::Barrier\n\nCreate a reduce barrier for ntasks tasks.  A reduce barrier supports computing a reduction with an associative operator op(::T, ::T) across tasks by calling reduce!(barrier[i], xᵢ::T).\n\n\n\n\n\n","category":"function"},{"location":"#Barriers.fuzzy_barrier","page":"Barriers.jl","title":"Barriers.fuzzy_barrier","text":"fuzzy_barrier(ntasks::Integer) -> barrier::Barrier\n\nCreate a fuzzy barrier for ntasks tasks.  In addition to the methods supported by \"plain\" barriers (see Barrier), fuzzy barriers support arrive!(barrier[i]) and depart!(barrier[i]) to do cycle! in two steps.\n\n\n\n\n\n","category":"function"},{"location":"#Barriers.fuzzy_reduce_barrier","page":"Barriers.jl","title":"Barriers.fuzzy_reduce_barrier","text":"fuzzy_reduce_barrier(op, T::Type, ntasks::Integer) -> barrier::Barrier\n\nCreate a fuzzy reduce barrier for ntasks tasks.  In addition to the methods supported by reduce barriers (see reduce_barrier], fuzzy reduce barriers support reduce_arrive!(barrier[i], xᵢ) and depart!(barrier[i]).\n\n\n\n\n\n","category":"function"},{"location":"#Barrier-constructors","page":"Barriers.jl","title":"Barrier constructors","text":"","category":"section"},{"location":"","page":"Barriers.jl","title":"Barriers.jl","text":"CentralizedBarrier\nDisseminationBarrier\nStaticTreeBarrier\nTreeBarrier\nFlatTreeBarrier","category":"page"},{"location":"#Barriers.CentralizedBarrier","page":"Barriers.jl","title":"Barriers.CentralizedBarrier","text":"CentralizedBarrier(ntasks::Integer)\n\nCreate the sense-reversing centralized barrier for ntasks tasks.  It supports fuzzy barrier methods.  For small ntasks (⪅ 32), it provides the best performance.\n\nSupported methods: cycle!, arrive!, depart!\n\n\n\n\n\n","category":"type"},{"location":"#Barriers.DisseminationBarrier","page":"Barriers.jl","title":"Barriers.DisseminationBarrier","text":"DisseminationBarrier(ntasks::Integer)\n\nCreate the dissemination barrier for ntasks tasks.  It provides the best performance especially for large ntasks (⪆ 32).\n\nSupported method: cycle!\n\n\n\n\n\n","category":"type"},{"location":"#Barriers.StaticTreeBarrier","page":"Barriers.jl","title":"Barriers.StaticTreeBarrier","text":"StaticTreeBarrier{NArrive,NDepart}(ntasks::Integer)\nStaticTreeBarrier{NArrive,NDepart,T}(op, ntasks::Integer)\n\nCreate the static tree barrier for ntasks tasks with the branching factor for arrival NArrive::Integer and departure NDepart::Integer specified by the type parameters.\n\nIt support fuzzy reduce barrier methods if the associative operations op and its domain T are given. Otherwise, it only supports fuzzy barrier methods.\n\nIt provides the best performance for large ntasks (⪆ 32) when reduction is needed.\n\nSupported methods: cycle!, reduce!\n\n\n\n\n\n","category":"type"},{"location":"#Barriers.TreeBarrier","page":"Barriers.jl","title":"Barriers.TreeBarrier","text":"TreeBarrier{NBranches}(ntasks::Integer)\nTreeBarrier{NBranches,T}(op, ntasks::Integer)\n\nCreate the tree barrier for ntasks tasks with the branching factor specified by the type parameter NBranches::Integer.\n\nIt support fuzzy reduce barrier methods if the associative operations op and its domain T are given. Otherwise, it only supports fuzzy barrier methods.\n\nSupported methods: cycle!, arrive!, depart! reduce!, reduce_arrive!\n\n\n\n\n\n","category":"type"},{"location":"#Barriers.FlatTreeBarrier","page":"Barriers.jl","title":"Barriers.FlatTreeBarrier","text":"FlatTreeBarrier{NBranches}(ntasks::Integer)\nFlatTreeBarrier{NBranches,T}(op, ntasks::Integer)\n\nCreate the tree barrier for ntasks tasks with the branching factor specified by the type parameter NBranches::Integer.  The departure is done serially (hence \"flat\").\n\nIt support fuzzy reduce barrier methods if the associative operations op and its domain T are given. Otherwise, it only supports fuzzy barrier methods.\n\nSupported methods: cycle!, arrive!, depart! reduce!.  reduce_arrive!.\n\n\n\n\n\n","category":"type"},{"location":"#Synchronizing-operations","page":"Barriers.jl","title":"Synchronizing operations","text":"","category":"section"},{"location":"","page":"Barriers.jl","title":"Barriers.jl","text":"cycle!\narrive!\ndepart!\nreduce!\nreduce_arrive!","category":"page"},{"location":"#Barriers.cycle!","page":"Barriers.jl","title":"Barriers.cycle!","text":"cycle!(barrier[i])\n\nUsing a barrier::Barrier, signal that the i::Integer-th task has reached a certain phase of the program and wait for other tasks to reach the same phase.\n\nExamples\n\njulia> using Barriers\n\njulia> xs = [1:3;];\n\njulia> barrier = Barrier(3);\n\njulia> @sync for i in 1:3\n           Threads.@spawn begin\n               x = i^2\n               xs[i] = x\n               cycle!(barrier[i])\n               xs[mod1(i + 1, 3)] -= x\n           end\n       end\n\njulia> xs\n3-element Vector{Int64}:\n -8\n  3\n  5\n\n\n\n\n\n","category":"function"},{"location":"#Barriers.arrive!","page":"Barriers.jl","title":"Barriers.arrive!","text":"arrive!(barrier[i])\n\nSignal that the i::Integer-th task has reached a certain phase but postpone the synchronization for the departure.\n\nA call to cycle! is equivalent to arrive! followed by depart!.  However, the task calling arrive! can work on some other local computations before calling depart! which waits for other tasks to call arrive!.\n\nNote that not all Barrier subtypes support arrive!.\n\nSee fuzzy_barrier, depart!.\n\nExamples\n\njulia> using Barriers\n\njulia> xs = [1:3;];\n\njulia> ys = similar(xs);\n\njulia> barrier = fuzzy_barrier(3);\n\njulia> @sync for i in 1:3\n           Threads.@spawn begin\n               x = i^2\n               xs[i] = x\n               arrive!(barrier[i])  # does not `wait`\n               ys[i] = x - 1  # do some work while waiting for other tasks\n               depart!(barrier[i])  # ensure all tasks have reached `arrive!`\n               xs[mod1(i + 1, 3)] -= x\n           end\n       end\n\njulia> xs\n3-element Vector{Int64}:\n -8\n  3\n  5\n\njulia> ys\n3-element Vector{Int64}:\n 0\n 3\n 8\n\n\n\n\n\n","category":"function"},{"location":"#Barriers.depart!","page":"Barriers.jl","title":"Barriers.depart!","text":"depart!(barrier[i])\ndepart!(barrier[i]) -> acc::T\n\nWait for all calls to arrive!(barrier[i]) or reduce_arrive!(barrier[i], _) for i = 1, 2, ..., ntasks.\n\nIf the barrier is a fuzzy reduce barrier (created, e.g., by fuzzy_reduce_barrier(op, T, ntasks)), it returns the result of reduction started by the prior call to reduce_arrive!(barrier[i], xᵢ::T).\n\nNote that not all Barrier subtypes support depart!.\n\nSee fuzzy_barrier, arrive!, reduce_arrive!.\n\n\n\n\n\n","category":"function"},{"location":"#Barriers.reduce!","page":"Barriers.jl","title":"Barriers.reduce!","text":"reduce!(barrier[i], xᵢ::T) -> acc::T\n\nUsing a reduce barrier barrier (created, e.g., by reduce_barrier(⊗, T, n)), it computes acc = x₁ ⊗ x₂ ⊗ ⋯ ⊗ xₙ.\n\nExamples\n\njulia> using Barriers\n\njulia> xs = Float64[1:4;];\n\njulia> barrier = reduce_barrier(+, Float64, length(xs));\n\njulia> @sync for i in eachindex(xs)\n           Threads.@spawn begin\n               x = i^2\n               s = reduce!(barrier[i], x)\n               m = s / length(xs)\n               xs[i] = x - m\n           end\n       end\n\njulia> xs\n4-element Vector{Float64}:\n -6.5\n -3.5\n  1.5\n  8.5\n\n\n\n\n\n","category":"function"},{"location":"#Barriers.reduce_arrive!","page":"Barriers.jl","title":"Barriers.reduce_arrive!","text":"reduce_arrive!(barrier[i], xᵢ::T)\n\nUsing a fuzzy reduce barrier barrier (created, e.g., by fuzzy_reduce_barrier(op, T, ntasks)), it initiates the reduction across tasks. The result of the reduction can be retrieved by a call to depart!(barrier[i]) once all tasks have called reduce_arrive!.\n\nExamples\n\njulia> using Barriers\n\njulia> xs = Float64[1:4;];\n\njulia> ys = similar(xs);\n\njulia> barrier = fuzzy_reduce_barrier(+, Float64, length(xs));\n\njulia> @sync for i in eachindex(xs)\n           Threads.@spawn begin\n               x = i^2\n               reduce_arrive!(barrier[i], x)\n               ys[i] = x - 1\n               s = depart!(barrier[i])\n               m = s / length(xs)\n               xs[i] = x - m\n           end\n       end\n\njulia> xs\n4-element Vector{Float64}:\n -6.5\n -3.5\n  1.5\n  8.5\n\njulia> ys\n4-element Vector{Float64}:\n  0.0\n  3.0\n  8.0\n 15.0\n\n\n\n\n\n","category":"function"}]
}
